use mongodb::{Database, bson::doc};

use crate::{
    errors::DBoError,
    mongo::{case_insensitive_collation, models::Player},
};

impl Player {
    /// Find a **single** player account by case-insensitively searching for their **entire** email
    /// address.
    ///
    /// ### Arguments
    /// - `db`: The MongoDB database
    /// - `email`: The email address to search for
    ///
    /// ### Returns
    /// - `Ok`: The player document
    /// - `Err`:
    ///   - `DBoError::NoMatch`: if no match could be found
    ///   - `DBoError::ServerSideError`: if the query failed
    pub async fn find_by_email(db: &Database, email: &str) -> Result<Player, DBoError> {
        let query = db
            .collection::<Self>(&Self::collection())
            .find_one(doc! { "email": email })
            .collation(case_insensitive_collation())
            .await;

        match query {
            Ok(opt) => match opt {
                Some(player) => Ok(player),
                None => Err(DBoError::NoMatch),
            },
            Err(e) => {
                eprintln!("{:?}", e);
                Err(DBoError::mongo_driver_error())
            }
        }
    }

    /// Find a **single** player account by case-insensitively searching for their **entire**
    /// username.
    ///
    /// ### Arguments
    /// - `db`: The MongoDB database
    /// - `username`: The username to search for.
    ///
    /// ### Returns
    /// - `Ok`: The matching player document
    /// - `Err`:
    ///   - `DBoError::NoMatch`: if no match could be found
    ///   - `DBoError::ServerSideError`: if the query failed
    pub async fn find_by_username(db: &Database, username: &str) -> Result<Player, DBoError> {
        let query = db
            .collection::<Self>(&Self::collection())
            .find_one(doc! { "username": username })
            .collation(case_insensitive_collation())
            .await;

        match query {
            Ok(opt) => match opt {
                Some(player) => Ok(player),
                None => Err(DBoError::NoMatch),
            },
            Err(e) => {
                eprintln!("{:?}", e);
                return Err(DBoError::mongo_driver_error());
            }
        }
    }

    /// Find a **single** player account by case-insensitively searching for their **entire** email
    /// address *or* username.
    ///
    /// ### Arguments
    /// - `db`: The MongoDB database
    /// - `username_or_email`: The username **or** email address to search for.
    ///
    /// ### Returns
    /// - `Ok`: The matching player document
    /// - `Err`:
    ///   - `DBoError::NoMatch` if no match could be found
    ///   - `DBoError::ServerSideError` if the query failed
    pub async fn find_by_email_or_username(
        db: &Database,
        username_or_email: &str,
    ) -> Result<Player, DBoError> {
        let query = db
            .collection::<Self>(&Self::collection())
            .find_one(doc! { "$or": [ { "username": username_or_email }, { "email": username_or_email } ] })
            .collation(case_insensitive_collation())
            .await;

        match query {
            Ok(opt) => match opt {
                Some(player) => Ok(player),
                None => Err(DBoError::MissingDocument),
            },
            Err(e) => {
                eprintln!("{:?}", e);
                return Err(DBoError::mongo_driver_error());
            }
        }
    }

    /// Find a **single** player account by searching for their **player_id**.
    ///
    /// **Note**: This is **not** a search by the OID generated by MongoDB.
    ///
    /// ### Arguments
    /// - `db`: The MongoDB database
    /// - `player_id`: The id to search for.
    ///
    /// ### Returns
    /// - `Ok`: The matching player document
    /// - `Err`:
    ///   - `DBoError::NoMatch` if no match could be found
    ///   - `DBoError::ServerSideError` if the query failed
    pub async fn find_by_id(db: &Database, player_id: &str) -> Result<Player, DBoError> {
        let query = db
            .collection::<Self>(&Player::collection())
            .find_one(doc! { "player_id": player_id })
            .await;

        match query {
            Ok(opt) => match opt {
                Some(player) => Ok(player),
                None => Err(DBoError::NoMatch),
            },
            Err(e) => {
                eprintln!("{:?}", e);
                return Err(DBoError::mongo_driver_error());
            }
        }
    }
}
